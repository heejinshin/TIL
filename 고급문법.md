# 고급문법

## 제너레이터(생성자)

- 생성자는 원본이 되는 데이터가 없더라도 순회할 수 있다. 순회하면서 데이터를 생성하기 때문이다. 따라서 무한에 가까워지는 숫자까지 메모리를 쓰지 않고도 컬렉션 흉내를 낼 수 있다.

- 생성자는 yield문이 포함된 함수를 사용하여 만들 수 있다. 안쓰면 일반함수. (변환함수 자체가 안일어남)

- yield문은 return처럼 정지하되 나중에 다시 실행하면 정지했던 위치부터 이어 실행한다. 

- 생성자의 장점은 만약 루프를 40억번 돌린다고 했을때 리스트에 40억개의 데이터를 저장하고 있는것은 매우 메모리 낭비이므로 필요할 때 계산에 의해 이를 순차적으로 생성할 수 있게 만드는 것이다. range함수 처럼 필요할 때 생성해서 나오게 만드는 것이다. 

  ~~~ python
  #1~n까지의 수 중에서 3과 4의 공배수를 뽑아주는 제너레이터를 작성하세요 
  #n은 매개변수로 전달한 값 사용
  def common(n):
      for x in range(1,n): 
          if x%3==0 and x%4==0:
              yield x
  
  for n in common(100):       #n은 yield의 x
      print (n, end= ',')
  ~~~

  

## 지역함수

지역변수처럼 함수 안에 정의되는 함수이다. 따라서 코드블럭 한단계 위(해당 함수 바깥)에서 호출했을때 정의되지 않은 존재로 나온다. 이를 return을 통해 외부로 전달이 가능하다. 

사용하는 이유는 함수의 동작이 복잡해져 일부 동작을 내부에 정의해주는 것이다. 함수 내부의 반복되는 코드를 통합하니까 소스가 짧아지고 관리하기가 좀더 용이하겠다. 

그렇다면 바깥함수가 하는 일은 뭔가, 지역변수를 함수 내에 정의해놓고 그 지역변수를 return시킨다. 여기서 return은 지역함수 내부의 참조를 리턴하는 것이다. 따라서 이 바깥함수를 실행시켜 대입받은 객체는 함수의 참조값을 갖는 변수가 된다. 그렇게 되면 내부 지역함수를 참조할 수 있게되고 그 기능을 그대로 실행한다. 재사용하기 용이한거지. 

인사말 함수를 만들어보자. 

~~~ python
def makeHello(message):
	def hello(name):
		print(f{message},{name})
	return hello

enghello = makeHello("hi, how're u")
korhello = makeHello("안녕, 어떻게 지내니")

enghello('jeff')
korhello('kim')
~~~

이를 출력하면 makeHello에 전달된 message인수도 잘 출력되는 것을 볼 수 있다. 원래 매개변수는 지역변수여서 함수 리턴시 사라지는데, 여기선 예외가 적용된다고 한다. 지역변수가 지속시간이 긴 함수에 의해 계속 사용되는 것으로 파이썬은 이 변수를 없애지 않고 클로저(Closure)라는 구조를 만들어 이를 계속 유지한다. 따라서 message함수로 전달된 메시지 문자열은 hello함수 정의문이 계속 갖고있게 된다. 



## 데코레이터

이름이 의미하듯이 뭔가 더 꾸며주는 기능이다. 함수에 더 필요한 기능을 살을 붙여 만든다. 함수를 래핑(wrapping)하여 원하는 코드를 추가하는 것이라 말한다. 즉, 하나의 함수를 기반으로 또 다른 함수를 반환하는 함수. 

중심 개념이 되는 것은 함수객체를 담은 변수를 다른 함수에 인자로 넘겨 호출이 가능하다는 것이다. (일급객체,매개변수가 없는 함수면 다 가능하다) 그리고 내부 함수가 외부함수의 인자를 기억하고 있다.(클로저)

1. Wrapper()함수사용
2. @outer, 데코레이터임을 직관적으로 표기

~~~ python
def outer(func):
		def wrapper():
				print("-"*20)
				func()
				print("-"*20)
		return wrapper
	
@outer
def inner():
		print("결과 출력")
		
inner()
~~~



inner가 outer의 wraaper함수를 참조하여 wrapper의 명령대로 실행할 수 있게 된다. inner의 명령은 wrapper안에 func()문에서 실행되는 것. 

@outer 데코레이터 기능이 우리가 누군가를 코멘트할 때 주로 쓰는 기능이다. 쉽게 생각해서 참조를 걸어준다고 볼 수 있는 것 같다. 이를 통해 inner가 outer에 의해 래핑됨을 직관적으로 알 수 있다. 

@를 쓰지 않는다면 표현되는 실행문은 outer(inner)이다. 감싸는 형태로 래핑한다고 하는 것이다. 