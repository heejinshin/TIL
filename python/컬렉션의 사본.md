# 컬렉션의 사본

## 리스트의 사본

list1 = [1, 2, 3] -> 오른쪽 리스트를 왼쪽 변수에 저장하라

list2 = list1 -> llist2에 list1을 복사해라

복사본인지 원본인지 알 수 있는 방법-> 한쪽을 수정해본다. 두 리스트가 독립된 사본이 아니라 같은 메모리를 가리키고 있기 때문에 같이 바뀐다. 

두 리스트를 완전히 독립적으로 만드려면 copy메서드를 써야한다. 

~~~ python
list1 = [1, 2, 3]
list2 = list1.copy()

list2[1] = 100
print(list1)>>> [1, 2, 3]
print(list2)>>> [1, 100, 3]
#list1과 list2과 다르게 출력, 독립된 사본임을 알 수 있다. 
~~~

~~~ 
list2 = list1[:]
# [:]은 전체 범위를 의미한다. 위는 독립된 리스트다. list의 처음부터 끝까지 범위를 추출하여 새로운 리스트를 만든뒤 list2에 대입한 것
~~~

	## is 연산자

is 연산자를 통해 복사된 두 리스트가 원본이 같은지 아닌지 조사한다. 불리언값을 리턴한다. 

~~~ python
list1 = [1, 2, 3]
list2 = list1   #list2 = [1, 2, 3]    (list1과 원본일치)
list3 = list1.copy()    #list3 = [1,2,3] (list1과 독립)

print("1==2", list1 is list2)    #True
print("1==3", list1 is list3)    #False
print("2==3", list2 is list3)    #False
~~~

책의 설명에는 두 변수가 같은 객체를 가리키고 있는지 조사한다고 되어있다. list2는 list1을 대입받은 것이므로 같은 객체를 가리키고 있다. 두 리스트가 가리키는 대상이 같아 같다고 하는것이다. 이 상태에서 둘 중 어느 리스트를 수정해보면 나머지 리스트가 영향을 받는다. 반면 list3은 copy메서드로 list1의 사본을 뜬것이어서 메모리가 완전히 분리된 객체이다. 따라서 list2와 list3도 다른 변수. 컬렉션에 대한 대입은 단순히 별명을 하나 더 만드는것!

### 상수객체에 대한 대입

파이썬은 상수까지도 객체로 취급하는데 이를 대입했을 때는 사본으로만 존재하게 된다. 영향을 주지 않는다. 

~~~ 
a = 1
b = a
b = 2
print(a) >>> 1
print(b) >>> 2
-----------------
a = [1, 2, 3]
b = a
b[1] = 100
print(a) >>> [1, 100, 3]
print(b) >>> [1, 100, 3]
~~~

위와같이 컬렉션과는 달리 상수 대입 변수는 참조 변수가 변경되는 독립적인 사본이 된다. 
